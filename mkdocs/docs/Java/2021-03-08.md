---
layout: index
title: "2021-Kickoff"
category: java
date: 2021-03-08 09:03:55
---

# 2021-Kickoff

## Spring
https://processon.com/signup?f=index

1. Spring程序是如何启动的
2. Spring是如何加载配置文件到应用程序的？
3. BeanDefinitionReader
4. BeanFactory
5. 彻底搞定Spring的refresh方法
6. BeanPostProcessor接口
7. BeanFactoryPostProcessor接口
8. SpringBean有没有必要实现Aware接口
9. 彻底理解SpringBean的生命周期
10. 循环依赖问题
11. FactoryBean接口的作用
12. Bean的初始化都经历什么
13. cglib和jdk动态代理
14. Aop如何处理的


## JVM Tunning

```
java -XX:+PringFlagsFinal

java -Xms200M -Xmx200M -XX:+PrintGC 
```
http://www.oracle.com/technetwork/java/javase/documentation/index.html 


> Garbage Collectors

```
<Serial, SerialOld>, <ParNew, CMS>, <Parallel Scavenge, Parallel Old> - G1

jdk1.8使用G1没有问题

```


> JVM tuning tool
- alibaba arthas
- JConsole
- JProfile


```
jps

top -Hp <processID>
jmap histo <ThreadID> | head -20
trace ABC a

#hot load class
redefine 

```

## CAS

最底层是一条汇编指令```lock cmpxchg```

## JUC

![偏向锁](./images/java/03-08_1.png)  
![markword](./images/java/03-08_2.png)

3. 默认synchronized(o)

00->轻量级锁，默认情况下偏向锁的开启有个4秒延时，因为JVM虚拟机本身有一些默认启动的线程，这些线程之间肯定会有竞争，如果上来就是用偏向锁，就会不断的造成锁撤销，锁升级，效率变低。

```
-XX:BiasedLockingStartupDelay=0
```

4. 如果设定上述参数

```new Object``` -> 101 偏向锁 -> 线程ID为0 -> Anonymous BiasedLock 打开偏向锁，new 出来的对象，默认就是一个可偏匿名对象101

5. 如果线程上有锁

上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程，偏向锁不可重偏向，批量偏向，批量撤销

6. 如果有线程竞争

撤销偏向锁，升级轻量级锁，线程在自己的线程栈生成LockRecord, 用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者获得锁

7. 如果竞争加剧

情况1：有线程超过10次自旋，```-XX:PreBloackSpin```, 后者自旋的线程数超过CPU核数的一半，1.6之后，加入自适应自旋Adapative Self Spining，JVM自己控制
情况2： 升级重量级锁，向操作系统申请资源，线程挂起，进入等待队列，等待操作系统的调度

> 轻量级锁重量级锁的hashcode存在什么地方？

答案：线程栈中，轻量级锁的LR种，或者代表重量级锁的ObjectMonitor的成员中

> 为什么有自旋锁还需要重量级锁

答案： 自旋锁是消耗CPU资源的，如果线程执行时间比较长，而同时等待的线程比较多，CPU会被大量消耗在等待上，重量级锁如果获取不到，就进入到等待队列中，不会消耗CPU

> 偏向锁一定比自旋锁效率高么？

答案：不一定。在明知道会有多线程竞争的情况下，偏向锁会涉及锁撤销，升级为轻量级锁。


