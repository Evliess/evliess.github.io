---
layout: index
title: "UnderstandingJVM"
category: java
date: 2020-02-16 11:03:55
---

# Understanding JVM - version 2


## Chapter2 Java内存区域与内存溢出异常

### 对象的创建

1\. 当虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类符号的引用，并检查这个类是否被加载，解析，初始化。如果没有，必须先执行类的加载。

2\. 当类加载检查通过后，虚拟机为新的对象分配内存。对象所需要的内存大小在类加载完成之后便可以确定。

3\. 内存分配完成之后，将分配的内存初始化零值，除了对象头的部分。

4\. 虚拟机设置对象，标记这个对象是哪个类的实例，如何找到类的元数据信息，对象的hashcode，对象的GC年龄等信息。

### 对象在内存中的结构

- 对象头(Header): 包含HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳，类型指针（指向类元数据的指针）。

- 实例数据(Instance data)

- 对齐填充(Padding)


> String.intern() 

该方法是一个native方法。它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到字符串常量池中，并且返回此String对象的引用。

### 对象的访问方式

Java程序需要通过栈上的reference数据来操作对上的具体对象。

- 句柄：在Java的对上化分一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象的实例数据与类型数据各自的具体地址信息。优点是在对象被移动的时候只会改变句柄中的实例数据的指针，reference本身不需要要修改。

- 指针：reference中存储的就是对象的地址。优点是访问速度快。

## Chapter3 垃圾收集器与内存分配策略

### 判断对象已死的算法

名称|优点|缺点
---|---|---
引用计数算法|实现简单，效率高|无法解决对象之间相互循环引用的问题
可达性分析算法(GC Roots)||

### 引用的类型

- 强引用 垃圾回收器永远不会回收被强引用的对象

- 软引用 在系统内存不够用的时候，会把这部分对象列入第二次垃圾回收的对象，如果第二次回收内存还不够，则OOM。

- 弱引用 弱引用的对象只能存活到下次垃圾回收之前。无论内存是否够用，下次垃圾回收一定会回收这部分对象。

- 虚引用 为对象设置虚引用的目的就是能在这个对象被回收器回收时收到一个通知。

> 对象的finalize()只会被系统自动调用一次。


### 垃圾收集算法

- 标记-清除算法

缺点：效率低，内存碎片化严重

- 复制算法 将内存分为两部分，先用一部分。需要回收的时候将存活的对象复制到另一部分。

- 标记整理算法

- 分代收集算法 
对新生代使用复制算法，对老年代使用标记整理算法

### 垃圾回收器的实现

- Serial收集器  Stop the Wolrd，简单高效

- ParNew收集器 Serial收集器的多线程版本

- Parallel Scavenge收集器 是一个新生代收集器，复制收集器，并行多线程收集器，主要关注的CPU的吞吐量。-XX:MaXGCPauseMillis控制最大垃圾收集停顿时间 -XXMaxGCTimeRatio直接设置吞吐量大小。 吞吐量=CPU运行客户代码的时间/CPU运行客户代码的时间+垃圾回收时间

- CMS收集器 以获取最短停顿时间，并发收集，低停顿

- G1收集器 并行并发，分代收集，标记整理清除，可预测停顿

### 内存分配与回收策略

- 新生代在Eden上分配
- 大对象直接进去老生代
- 长久存活的对象直接进入老年代

## Chapter4 虚拟机性能监控与故障处理工具 p124

## Chapter5 调优案例分析与实践 p155

## Chapter6 类文件结构 p185 //TODO

## Chapter7 虚拟机类加载机制 p232

## Chapter8 虚拟机字节码执行引擎 p259

## Chapter9 类加载及执行子系统的案例与实践 p299

## Chapter10 编译器优化 p325

## Chapter11 运行期优化 p352

## Chapter12 Java内存模型与线程 p383 //TODO

## Chapter13 线程安全与锁优化 p408   //TODO






